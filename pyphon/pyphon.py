"""
Module with a number of functions useful for working with the output of the Penn Forced Aligner (CITATION, WEBSITE).
Eventual goal is to provide a set of functions for phonetic analysis similar in function to Praat (Boersma & Weenink, 2004+).

Depends on several functions from SciPy and Pylab/MatPlotLib.

"""
from scipy.io.wavfile import read
import numpy as np
from eelbrain import Dataset, Factor, Var
from matplotlib import axis, pyplot as plt, cm
from pylab import plot, show, subplot, specgram


class Textgrid:
    """
    Creates a textgrid object for with time intervals for phones and words.

    Standard textgrids (generated by Penn Forced Aligner) have
    two interval tiers: phone, word. Format entails the interval followed by
    its respective tier type.

    To keep with compatibility, exported textgrids are in secs.
    However, all attributes are in msecs.

    Parameters
    ----------
    fname: the textgrid to be interpreted

    Attributes
    ----------
    total_interval : Total duration of the recording
    phone_intervals : Time interval of phone
    word_intervals : Time interval of word
    phone_durs : Duration of phone
    word_durs : Duration of word
    transcripts : Pairing of word with its respective phones

    """
    def __init__(self, fname):
        textgrid = open(fname, 'r').read().replace('"', '')
        tiers = textgrid.split('IntervalTier')
        # removes header
        self._header = tiers.pop(0)

        phone_tier = tiers[0].strip().split()
        # specifies tier type
        self._tier1 = phone_tier.pop(0)
        self.total_interval = phone_tier.pop(0), phone_tier.pop(0)
        self.total_interval = np.array(self.total_interval, dtype=float)
        self.total_interval *= 1e3  # to convert secs to msecs
        # specifies number of phones
        self._n_phones = phone_tier.pop(0)
        self.phones = np.array(phone_tier[2::3])
        phone_start = map(float, phone_tier[0::3])
        phone_stop = map(float, phone_tier[1::3])
        self.phone_intervals = np.array((phone_start, phone_stop)).T
        self.phone_intervals *= 1e3  # to convert secs to msecs
        self.phone_durs = np.diff(self.phone_intervals).ravel()

        word_tier = tiers[1].strip().split()
        # specifies tier type
        self._tier2 = word_tier.pop(0)
        total_interval = word_tier.pop(0), word_tier.pop(0)
        total_interval = np.array(total_interval, dtype=float)
        total_interval *= 1e3
        np.testing.assert_array_equal(total_interval, self.total_interval)
        # specifies the number of words
        self._n_words = word_tier.pop(0)
        self.words = np.array(word_tier[2::3])
        word_start = map(float, word_tier[0::3])
        word_stop = map(float, word_tier[1::3])
        self.word_intervals = np.array((word_start, word_stop)).T
        self.word_intervals *= 1e3  # to convert secs to msecs
        self.word_durs = np.diff(self.word_intervals).ravel()

#         self.transcripts = []
#         word_start, word_stop = (self.word_intervals[:,0],
#                                  self.word_intervals[:,1])
#
#         phone_start, phone_stop = (self.phone_intervals[:,0],
#                                    self.phone_intervals[:,1])
#         phone_dict = {int(time): i for i, time in enumerate(phone_start)}
#         idx = [phone_dict[int(time)] for time in word_start]
#         phone_dict = {int(time): i for i, time in enumerate(phone_stop)}
#         idy = [phone_dict[int(time)] for time in word_stop]
#
#         for i,v in enumerate(zip(idx,idy)):
#             a,z = v
#             self.transcripts.append((self.words[i], list(self.phones[a:z+1])))

    def export_durs(self):
        ds = Dataset()
        idx = self.words == 'sp'
        words = self.words[~idx]
        durs = self.word_durs[~idx]
        reject = []
        for idx, word in enumerate(words):
            if word.startswith('*'):
                reject.append(idx)
                words[idx] = word[1:]
        reject = reject[1::2]
        reject = [r / 2 for r in reject]
        ds['words'] = Factor([first.lower() + second.lower() for first, second in
                              zip(words[::2], words[1::2])])
        ds['c1_dur'] = Var(durs[::2])
        ds['c2_dur'] = Var(durs[1::2])
        ds['accept'] = Var(np.ones(ds.n_cases, dtype=bool))
        ds['accept'][reject] = False
        return ds


class Sound:
    """
    Parent class for Pyphon figures.

    In order to subclass:

     - find desired figure properties and then use them to initialize
       the SoundFigure superclass; then use the
       :py:attr:`SoundFigure.figure` and :py:attr:`SoundFigure.canvas` attributes.

    """
    def __init__(self, soundfile, textgrid, **fig_kwargs):

        # basic sound file properties
        self.rate, self.data = read(soundfile)
        if self.data.shape[1] > 1:
            self.data = self.data[:, 0]
        self.time = [float(r) / self.rate for r in range(len(self.data))]
        self.textgrid = Textgrid(textgrid)
        self.fname = soundfile

#         # plotting features
#         frame = mpl_figure(**fig_kwargs)
#         # store attributes
#         self._frame = frame
#         self.figure = frame.figure
#         self.canvas = frame.canvas
#         self.canvas.mpl_connect('button_press_event', self.onclick)

    def onclick(self, event):
        self.xdata = event.xdata

    def plot(self, noverlap=0, cmap=cm.binary, window_length=20):
        """
        Function to give Praat-style waveform + spectrogram + textgrid plot
        time is given in sec units
        """
        # plot waveform
        subplot(3, 1, 1)
        plot(self.time, self.data, color='black', linewidth=0.2)

        # plot spectrogram
        subplot(3, 1, 2)
        nfft = int(float((window_length * self.rate)) / 1000)
        specgram(self.data, NFFT=nfft, noverlap=noverlap, cmap=cmap)
#         # add transcription:
#         subplot(3, 1, 3)
#         for interval, word in zip(self.textgrid.word_intervals, self.textgrid.words):
#             #plots the interval for each phone
#             plt.axvspan(interval[0], interval[1], facecolor='b')
#             # actually plot words:
#             plt.annotate(word, xy=(interval[0]+interval[1] / 2, .5), color='y')


class mpl_figure:
    def __init__(self, **fig_kwargs):
        "creates self.figure and self.canvas attributes and returns the figure"
        self.figure = plt.figure(**fig_kwargs)
        self.canvas = self.figure.canvas

    def Close(self):
        plt.close(self.figure)

    def SetStatusText(self, text):
        pass

    def redraw(self, axes=[], artists=[]):
        "Adapted duplicate of mpl_canvas.FigureCanvasPanel"
        self.canvas.restore_region(self._background)
        for ax in axes:
            ax.draw_artist(ax)
            extent = ax.get_window_extent()
            self.canvas.blit(extent)
        for artist in artists:
            ax = artist.get_axes()
            ax.draw_artist(ax)
            extent = ax.get_window_extent()
            self.canvas.blit(extent)

    def store_canvas(self):
        self._background = self.canvas.copy_from_bbox(self.figure.bbox)


